<ol>
<li>##Συνάρτηση calc():</li>
<ul>
    <li>Αρχικά η συνάρτηση αυτή έχει τρια ορίσματα: τη ρίζα του αριθμού(*n*), τον αριθμό(*nn*) και έναν αθροιστή στον οποίο αποθηκεύεται το άθροισμα των ψηφίων(*modsum*).</li>

    <li>Ακολουθεί μια αρχικοποίηση των zer, που είναι η μεταβλητή που χρησιμοποιούμε για να κάνουμε όλες τις πιθανές διαιρέσεις(10,100,1000 κλπ) στον αριθμό 
        και των *n1*, *n2* που χρησιμοποιούνται για το *mod* και *div* του αριθμού με το τότε *zer*.</li>
    
    <li>Σε κάθε κλήση της συνάρτησης ελέγχουμε αν το παρόν άθροισμα έχει ξεπεράσει το *n*, δηλαδή τη ρίζα του, οπότε επιστρέφουμε **false** αφού δεν έχει νόημα να συνεχίσουμε.</li>

    <li>Στη συνέχεια όσο ο αριθμός που ελέγχουμε είναι μεγαλύτερος από το *zer*, δηλαδή όσο μπορεί να εκτελεστεί η πράξη **div 10<sup>n</sup>** και να υπάρχει πηλίκο, ώστε να αποφευχθεί η περίπτωση ατέρμονα βρόγχου που οδηγεί σε **overflow** του *zer* (*γιατί αν για παράδειγμα καταλήξουμε σε ένα modsum μεγαλύτερο του n τότε η συνάρτηση θα επιστρέφει συνεχώς false χωρίς να ενημερώνει την nn και έτσι το while θα τρέχει συνέχεια αυξάνοντας το zer*), καλούμε αναδρομικά τη συνάρτηση. Αρχικά αποθηκεύουμε σε τοπικές μεταβλητές τα *div* και *mod* του αριθμού και στη συνέχεια βλέπουμε αν έχει νόημα να συνεχίσουμε να ελέγχουμε αυτήν την υποπερίπτωση. Δηλαδή συγκρίνουμε το μέχρι τώρα άθροισμα των ψηφίων και αν αυτό είναι μικρότερο από τη ρίζα του τότε σίγουρα ο συνδυασμός δε βρίσκεται σε εκείνο το κλαδί αφού ο αριθμός από εκείνο το σημείο και μετά θα σπάει σε περαιτέρω ψηφία, επομένως θα γίνεται όλο και μικρότερος. Καλούμε τη συνάρτηση με ορίσματα τη ρίζα του αριθμού, ως αριθμό που θα ελεχθεί το αποτέλεσμα από τη πράξη του div και προσθέτουμε στον αθροιστή το αποτέλεσμα της πράξης mod και αν η τιμή επιστροφής της είναι true τότε επιστρέφουμε αλυσιδωτά **true** στις προηγούμενες κλίσεις μέχρι να αδειάσει η στοίβα. Ουσιαστικά δηλαδή παίρνουμε τον αριθμό και εκτελούμε συνεχώς *div 10*, προσθέτοντας το *mod 10* στην *modsum*, μέχρι να φτάσουμε στο σημείο που μπορούμε να κρίνουμε αν έχει νόημα να συνεχίσουμε ή έχουμε εξαντλήσει όλες τις περιπτώσεις. Έτσι η τελευταία συνάρτηση επιστρέφει στην προηγούμενη συνάρτηση τη τιμή της και αν είναι **false** συνεχίζει το **while loop**, και βάζει μια νέα συνάρτηση στη στοίβα η οποία προκύπτει από πράξεις για *mod 100* και *div 100*, αν ικανοποιείται η **nn>zer**, και συνεχίζει έτσι μέχρι να βρει τον συνδυασμό ή μέχρι να εξαντλήσει όλες τις περιπτώσεις. Σε κάθε επανάληψη ελέγχουμε και αν βρήκαμε τον συνδυασμό αν επαληθεύεται η ισότητα αθροίσματος-ρίζας. Αυτός ο έλεγχος είναι υποχρεωτικός για να πάρουμε και τα αθροίσματα των ψηφίων για τα οποία δεν θα γίνει άλλη επανάληψη γιατί για παράδειγμα δε θα ικανοποιείται η **nn>zer**.</li>

    <li>Αφού εκτελέσει όλους τους υπολογισμούς και δε βρει το ζητούμενο άθροισμα τότε επιστρέφει false.</li>
</ul>

<li>##Απόδειξη της ιδιότητας του mod9:</li>

    Έστω *n* ο αριθμός και *r* η ρίζα του

    Ισχύει ότι ```**x + y = (x mod m + y mod m) mod m**``` και ```**x * y = (x mod m * y mod m) mod m**```, με *x*, *y*, *m* ακέραιοι
    Επιπλέον μπορούμε να εκφράσουμε όλα τα ψηφία του αριθμού ως πολλαπλάσια του 10<sup>k</sup> , *k* φυσικός, ανάλογα με τη θέση τους (πχ 123 = 1*100+2*10+3*1)
    Άρα με βάση τη παραπάνω ιδιότητα θα έχουμε, ```**d * 10<sup>k</sup> = (d mod 9 * 10<sup>k</sup> mod 9) mod 9**``` , όπου *d* ένας φυσικός 
    Είναι προφανές πως οι αριθμοί 99,999,9999κλπ είναι όλοι πολλαπλάσια του 9 και απέχουν 1 από 100,1000κλπ
    Οπότε ισχύει ότι ```**10<sup>k</sup> mod 9 = 1**```
    Οπότε η (1) γίνεται ```**(d mod 9 * 1) mod 9 = (d mod 9) mod 9 = z mod 9**```, όπου 0 <= z <= 8
    Επομένως αν βάλουμε το mod 9 σε κάθε ψηφίο (ή συνδυασμό ψηφίων) με βάση την πρώτη ιδιότητα καταλήγουμε ότι ```**n mod 9 = sum mod 9**```
    Οπότε έχουμε ```**n mod 9 = sum mod 9 = r mod 9**```
    Επίσης ```**n mod 9 = (r mod 9)<sup>2</sup> mod9**```
    
    Έστω **a = r mod 9**
    Επομένως πρέπει **a<sup>2</sup> mod 9 = a** που ισχύει μόνο όταν **a=1** ή **a=0**
    Άρα αποδείξαμε ότι **n mod 9 = 1** ή **n mod 9 = 0**

</o>